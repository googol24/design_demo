# design_demo
brief samples about the design pattern

# 简单工厂模式
> 简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类

# 策略模式
> 它定义了算法家族，分别封装起来，让它们之间可以相互替换。改模式让算法的变化不会影响到使用算法的用户

# 单一职责原则
> 对于一个类而言，应当仅有一个引起它变化的原因（一个类只有一个职责）

# 开放关闭原则
> 软件实体（类、模块、函数等）应该可以扩展，但是不能被修改（对扩展开放，对更改关闭）

# 依赖倒转原则
> 抽象不应该依赖细节，细节应该依赖于抽象（针对接口编程，不要针对实现编程）
* 高层模块不应该依赖于低层模块，两者都应该依赖于抽象
* 抽象不应该依赖细节，细节应该依赖于抽象
* 里式替换原则：子类型必须能够替换掉他们的父类型（子类型的可替换性使得使用父类型的模块在无需修改的情况下就可以扩展，开放关闭）

# 装饰模式(Decorator)
> 动态地给一个对象添加额外的职责。就增加功能来说，装饰模式比生成子类更为灵活
* 额外添加的职责一般都是仅仅为了满足某种特定情况下才会执行的特殊行为的需要
* 装饰模式把要装饰的功能单独得放在一个类中，并让这个类包装它所要装饰的对象（把类的核心职责与它的装饰功能分开，简化了原有的类）
* 因此，需要执行特殊行为的时候，客户代码可以在运行时有需要的、按照指定顺序使用装饰功能来包装对象

# 代理模式
> 为其他对象提供一种代理，以控制对这个对象的访问
* 给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用
* 中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口
* 开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能(只需要修改代理类而不需要再修改委托类)

