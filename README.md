# design_demo
brief samples about the design pattern

# 简单工厂模式
> 简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类

# 策略模式
> 它定义了算法家族，分别封装起来，让它们之间可以相互替换。改模式让算法的变化不会影响到使用算法的用户

# 单一职责原则
> 对于一个类而言，应当仅有一个引起它变化的原因（一个类只有一个职责）

# 开放关闭原则
> 软件实体（类、模块、函数等）应该可以扩展，但是不能被修改（对扩展开放，对更改关闭）

# 依赖倒转原则
> 抽象不应该依赖细节，细节应该依赖于抽象（针对接口编程，不要针对实现编程）
* 高层模块不应该依赖于低层模块，两者都应该依赖于抽象
* 抽象不应该依赖细节，细节应该依赖于抽象
* 里式替换原则：子类型必须能够替换掉他们的父类型（子类型的可替换性使得使用父类型的模块在无需修改的情况下就可以扩展，开放关闭）

# 装饰模式(Decorator)
> 动态地给一个对象添加额外的职责。就增加功能来说，装饰模式比生成子类更为灵活
* 额外添加的职责一般都是仅仅为了满足某种特定情况下才会执行的特殊行为的需要
* 装饰模式把要装饰的功能单独得放在一个类中，并让这个类包装它所要装饰的对象（把类的核心职责与它的装饰功能分开，简化了原有的类）
* 因此，需要执行特殊行为的时候，客户代码可以在运行时有需要的、按照指定顺序使用装饰功能来包装对象

# 代理模式
> 为其他对象提供一种代理，以控制对这个对象的访问
* 给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用
* 中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口
* 开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能(只需要修改代理类而不需要再修改委托类)

# 工厂方法模式
> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
* 简单工厂模式的进一步抽象和推广
* 与简单工厂相比，遵循了开放关闭原则，增加一种工厂类型只需要增加一个对应的工厂子类即可（不需要更改其他工厂子类。PS:在简单工厂模式中需要更改工厂类）

# 原型模式
> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
* 原型模式其实就是从一个对象在创建另外一个可定制的对象，而且不需要知道任何创建的细节，也提升了性能
* 浅复制：被复制的对象的所有（值类型）变量都含有与原来对象相同的值，而所有对其他对象的引用都仍指向原来的对象
* 深复制：被复制的对象的所有（值类型）变量都含有与原来对象相同的值，并且把引用对象的变量指向复制过的新对象，而不是原有被引用的对象
