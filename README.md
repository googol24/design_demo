# design_demo
brief samples about the design pattern

# 简单工厂模式
> 简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类

# 策略模式
> 它定义了算法家族，分别封装起来，让它们之间可以相互替换。改模式让算法的变化不会影响到使用算法的用户

# 单一职责原则
> 对于一个类而言，应当仅有一个引起它变化的原因（一个类只有一个职责）

# 开放关闭原则
> 软件实体（类、模块、函数等）应该可以扩展，但是不能被修改（对扩展开放，对更改关闭）

# 依赖倒转原则
> 抽象不应该依赖细节，细节应该依赖于抽象（针对接口编程，不要针对实现编程）
* 高层模块不应该依赖于低层模块，两者都应该依赖于抽象
* 抽象不应该依赖细节，细节应该依赖于抽象
* 里式替换原则：子类型必须能够替换掉他们的父类型（子类型的可替换性使得使用父类型的模块在无需修改的情况下就可以扩展，开放关闭）

# 装饰模式(Decorator)
> 动态地给一个对象添加额外的职责。就增加功能来说，装饰模式比生成子类更为灵活
* 额外添加的职责一般都是仅仅为了满足某种特定情况下才会执行的特殊行为的需要
* 装饰模式把要装饰的功能单独得放在一个类中，并让这个类包装它所要装饰的对象（把类的核心职责与它的装饰功能分开，简化了原有的类）
* 因此，需要执行特殊行为的时候，客户代码可以在运行时有需要的、按照指定顺序使用装饰功能来包装对象

# 代理模式
> 为其他对象提供一种代理，以控制对这个对象的访问
* 给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用
* 中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口
* 开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能(只需要修改代理类而不需要再修改委托类)

# 工厂方法模式
> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
* 简单工厂模式的进一步抽象和推广
* 与简单工厂相比，遵循了开放关闭原则，增加一种工厂类型只需要增加一个对应的工厂子类即可（不需要更改其他工厂子类。PS:在简单工厂模式中需要更改工厂类）

# 原型模式
> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
* 原型模式其实就是从一个对象在创建另外一个可定制的对象，而且不需要知道任何创建的细节，也提升了性能
* 浅复制：被复制的对象的所有（值类型）变量都含有与原来对象相同的值，而所有对其他对象的引用都仍指向原来的对象
* 深复制：被复制的对象的所有（值类型）变量都含有与原来对象相同的值，并且把引用对象的变量指向复制过的新对象，而不是原有被引用的对象

# 模板方法模式
> 定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法可以使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
* 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但是其个别步骤在更详细的层次上的实现可能有所不同的时候，通常考虑用模板方法模式来处理
* 模板方法模式是通过把不变的行为搬移到超类，去除子类中重复的代码来体现它的优势（一个很好的代码复用平台）
* 当不变的和可变的行为在子类的实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式可以把这些行为搬移到单一的地方，这样就帮助子类摆脱了重复的不变行为的纠缠

# 迪米特法则（最少知识原则）
> 如果两个类不必彼此通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用
* 迪米特法则强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限（一个类包装好自己的private状态，不需要让别的类知道的字段或者行为就不需要公开）
* 迪米特法则的根本思想，是强调了类之间的松耦合
* 类之间的耦合越弱，越有利于复用。一个处于弱耦合的类被修改，不会对有关系的类造成波及（信息隐藏促进软件复用）

# 外观模式（门面模式）
> 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这一接口使得这一子系统更加容易使用
* 首先，在设计初期阶段，应该要有意识地将不同的两个层分离，在层与层之间建立外观Facade,为复杂的子系统提供简单的接口
* 其次，在开发阶段，子系统往往因为不断地重构演化而变得越来越复杂，此时增加Facade可以提供一个简单的接口，减少外部用户程序与复杂的子系统之间的依赖
* 第三，在维护一个大型系统时，可能这个系统已经非常难以维护和扩展了，当新功能开发依赖于它的时候，可以增加Facade类，让新功能与Facade交互,Facade与遗留代码交互